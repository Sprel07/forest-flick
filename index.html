<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Forest Flick Multiplayer</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#070a14; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; color:rgba(255,255,255,0.92); }
    .wrap { max-width: 1160px; margin: 0 auto; padding: 18px; }
    h1 { margin: 0 0 4px 0; font-size: 40px; letter-spacing: 0.2px; }
    .sub { opacity:0.85; margin-bottom: 10px; }

    .pillbar { display:flex; gap:10px; flex-wrap:wrap; margin-bottom: 14px; }
    .pill { padding:6px 10px; border-radius:999px; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.10); font-size: 12px; opacity:0.95; }

    .grid {
      display:grid;
      grid-template-columns: 1.4fr 1fr;
      gap: 14px;
      align-items: start;
    }
    .card {
      background: radial-gradient(900px 550px at 20% 10%, rgba(70,120,255,0.14), rgba(0,0,0,0.0));
      border:1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.45);
      backdrop-filter: blur(6px);
    }
    .row { display:flex; gap:10px; flex-wrap: wrap; align-items:center; }
    .row > * { flex: 0 0 auto; }
    label { font-size: 12px; opacity:0.85; display:block; margin-bottom: 4px; }
    input, select {
      background: rgba(0,0,0,0.32);
      color: rgba(255,255,255,0.92);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 10px;
      padding: 10px 10px;
      outline: none;
      min-width: 180px;
    }
    input:focus, select:focus { border-color: rgba(130,160,255,0.7); }

    .btn {
      cursor:pointer;
      border:1px solid rgba(130,160,255,0.55);
      background: rgba(70,120,255,0.16);
      color: rgba(255,255,255,0.95);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 700;
      transition: transform 0.06s ease, background 0.12s ease, border-color 0.12s ease;
      user-select: none;
    }
    .btn:hover { background: rgba(70,120,255,0.22); border-color: rgba(130,160,255,0.75); }
    .btn:active { transform: scale(0.98); }
    .btn.secondary { border-color: rgba(255,255,255,0.18); background: rgba(255,255,255,0.06); font-weight: 650; }
    .btn.danger { border-color: rgba(255,120,120,0.5); background: rgba(255,120,120,0.14); }
    .btn:disabled { opacity: 0.45; cursor:not-allowed; }

    .twoCol { display:grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .charGrid { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 8px; }
    .char {
      cursor:pointer;
      padding: 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
      transition: transform 0.06s ease, border-color 0.12s ease;
      display:flex;
      gap: 10px;
      align-items: center;
    }
    .char:hover { border-color: rgba(140,180,255,0.55); }
    .char.selected { border-color: rgba(140,180,255,0.85); box-shadow: 0 0 0 2px rgba(140,180,255,0.20) inset; }
    .char .icon {
      width: 34px; height: 34px; border-radius: 999px;
      border: 2px solid rgba(255,255,255,0.18);
      display:grid; place-items:center;
      font-weight: 900;
      background: rgba(255,255,255,0.06);
    }
    .char .meta { line-height: 1.2; }
    .small { font-size: 12px; opacity:0.85; }

    .lobbyList { margin-top: 8px; display:flex; flex-direction:column; gap:8px; }
    .playerRow {
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.18);
      border-radius: 12px;
      padding: 10px 10px;
    }
    .playerLeft { display:flex; align-items:center; gap:10px; }
    .dot { width: 14px; height:14px; border-radius:999px; background:#9ad; border:2px solid rgba(255,255,255,0.18); }
    .tag { font-size: 12px; padding: 4px 8px; border-radius: 999px; border:1px solid rgba(255,255,255,0.14); background: rgba(255,255,255,0.06); opacity:0.92; }

    .hudHint { margin-top: 10px; font-size: 12px; opacity:0.82; line-height: 1.35; }
    .toast { margin-top: 10px; font-size: 13px; opacity:0.95; }

    canvas {
      width: 100%;
      height: auto;
      background: radial-gradient(1200px 700px at 20% 20%, #172046, #070a14);
      border-radius: 16px;
      border:1px solid rgba(255,255,255,0.12);
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      touch-action: none;
      display:block;
    }

    .hidden { display:none !important; }
    .foot { margin-top: 10px; opacity:0.8; font-size: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Forest Flick Multiplayer</h1>
    <div class="sub">Turn based. One flick per turn. Physics resolves, then next player goes. Race mode or Boss co-op mode.</div>

    <div class="pillbar">
      <div class="pill" id="pillRoom">Room: none</div>
      <div class="pill" id="pillYou">You: -</div>
      <div class="pill" id="pillHost">Host: -</div>
      <div class="pill" id="pillWs">WS: connecting</div>
    </div>

    <div class="grid">
      <div class="card" id="menuCard">
        <div class="twoCol">
          <div>
            <label>Your name</label>
            <input id="nameInput" placeholder="Type your name" />
          </div>
          <div>
            <label>Room code</label>
            <input id="roomInput" placeholder="EX: TT12" />
          </div>
        </div>

        <div class="row" style="margin-top: 10px;">
          <button class="btn secondary" id="btnCreate">Create</button>
          <button class="btn" id="btnJoin">Join</button>
          <span class="small" id="menuMsg"></span>
        </div>

        <div style="margin-top: 14px;">
          <label>Choose your forest friend</label>
          <div class="charGrid" id="charGrid"></div>
          <div class="hudHint">Pick a character, then Ready. Host can set mode and Start.</div>
        </div>
      </div>

      <div class="card" id="lobbyCard">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
          <div>
            <div style="font-weight:800; font-size:18px;">Lobby</div>
            <div class="small" id="lobbyModeText">Mode: -</div>
            <div class="small" id="lobbyMapText">Map: -</div>
          </div>
          <div class="row">
            <select id="modeSelect">
              <option value="race">Obstacle Race</option>
              <option value="boss">Boss Co-op</option>
            </select>
            <button class="btn secondary" id="btnSetMode">Set Mode (Host)</button>
          </div>
        </div>

        <div class="lobbyList" id="lobbyList"></div>

        <div class="row" style="margin-top:10px;">
          <button class="btn" id="btnReady">Ready</button>
          <button class="btn secondary" id="btnStart">Start (Host)</button>
          <button class="btn danger" id="btnReset">Reset (Host)</button>
        </div>

        <div class="row" style="margin-top:10px;">
          <button class="btn secondary" id="btnReloadMap">Reload Map (Host)</button>
          <button class="btn secondary" id="btnResetPos">Reset Positions (Host)</button>
        </div>

        <div class="toast" id="toast"></div>
        <div class="hudHint" id="hint"></div>
      </div>
    </div>

    <div style="margin-top: 14px;">
      <canvas id="c" width="960" height="540"></canvas>
      <div class="foot">Controls during your turn: click and drag from your ball to aim, release to flick. During movement: Space or tap Dash button (if you have charges).</div>
      <div class="row" style="margin-top:10px;">
        <button class="btn secondary" id="btnDash">Dash</button>
      </div>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const c = $("c");
  const ctx = c.getContext("2d");

  const pillRoom = $("pillRoom");
  const pillYou = $("pillYou");
  const pillHost = $("pillHost");
  const pillWs = $("pillWs");

  const nameInput = $("nameInput");
  const roomInput = $("roomInput");
  const btnCreate = $("btnCreate");
  const btnJoin = $("btnJoin");
  const menuMsg = $("menuMsg");

  const charGrid = $("charGrid");

  const modeSelect = $("modeSelect");
  const btnSetMode = $("btnSetMode");
  const btnReady = $("btnReady");
  const btnStart = $("btnStart");
  const btnReset = $("btnReset");
  const btnReloadMap = $("btnReloadMap");
  const btnResetPos = $("btnResetPos");
  const lobbyList = $("lobbyList");
  const lobbyModeText = $("lobbyModeText");
  const lobbyMapText = $("lobbyMapText");
  const toastEl = $("toast");
  const hintEl = $("hint");
  const btnDash = $("btnDash");

  // Characters
  const CHARACTERS = [
    { id: "agouti", label: "Agouti", key: "A", trait: "First launch each round is stronger." },
    { id: "frog", label: "Tree Frog", key: "F", trait: "Keeps more speed on wall rebounds." },
    { id: "hummingbird", label: "Hummingbird", key: "H", trait: "Starts with 1 dash charge each round." },
    { id: "manicou", label: "Manicou", key: "M", trait: "Starts with a shield each round (blocks one hit)." }
  ];

  const PALETTE = [
    "#7dd3fc", "#fb7185", "#a78bfa", "#fbbf24",
    "#34d399", "#60a5fa", "#f472b6", "#fca5a5"
  ];

  // State
  let ws = null;
  let myId = null;
  let roomCode = null;
  let hostId = null;
  let snapshot = null;
  let selectedChar = "agouti";
  let isReady = false;

  // Camera
  const cam = { x: 0, y: 0, w: c.width, h: c.height };

  // Aim drag
  let dragging = false;
  let dragStart = null; // world position
  let dragNow = null;   // world position

  function wsUrl() {
    const proto = (location.protocol === "https:") ? "wss" : "ws";
    return `${proto}://${location.host}`;
  }

  function connect() {
    ws = new WebSocket(wsUrl());
    pillWs.textContent = "WS: connecting";

    ws.onopen = () => {
      pillWs.textContent = "WS: open";
    };
    ws.onclose = () => {
      pillWs.textContent = "WS: closed";
      setTimeout(connect, 800);
    };
    ws.onerror = () => {
      pillWs.textContent = "WS: error";
    };
    ws.onmessage = (ev) => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }

      if (msg.t === "joined") {
        myId = msg.id;
        roomCode = msg.code;
        hostId = msg.hostId;

        pillRoom.textContent = `Room: ${roomCode}`;
        pillYou.textContent = `You: ${myId}`;
        pillHost.textContent = `Host: ${hostId}`;

        // lock name field after join
        nameInput.disabled = true;
        roomInput.value = roomCode;

        menuMsg.textContent = "";
      }

      if (msg.t === "err") {
        menuMsg.textContent = msg.m || "Error";
      }

      if (msg.t === "snap") {
        snapshot = msg;
        hostId = msg.room.hostId;
        pillHost.textContent = `Host: ${hostId}`;
        renderLobby();
      }
    };
  }

  // UI buttons
  btnCreate.onclick = () => {
    clickFX(btnCreate);
    const name = cleanName(nameInput.value);
    if (!name) { menuMsg.textContent = "Enter a name first"; return; }
    wsSend({ t: "create", name });
  };

  btnJoin.onclick = () => {
    clickFX(btnJoin);
    const name = cleanName(nameInput.value);
    const code = String(roomInput.value || "").trim().toUpperCase();
    if (!name) { menuMsg.textContent = "Enter a name first"; return; }
    if (!code) { menuMsg.textContent = "Enter a room code"; return; }
    wsSend({ t: "join", name, code });
  };

  btnSetMode.onclick = () => {
    clickFX(btnSetMode);
    wsSend({ t: "set_mode", mode: modeSelect.value });
  };

  btnReady.onclick = () => {
    clickFX(btnReady);
    isReady = !isReady;
    wsSend({ t: "ready", v: isReady });
    btnReady.textContent = isReady ? "Ready (On)" : "Ready";
  };

  btnStart.onclick = () => {
    clickFX(btnStart);
    wsSend({ t: "start" });
  };

  btnReset.onclick = () => {
    clickFX(btnReset);
    wsSend({ t: "reset" });
  };

  btnReloadMap.onclick = () => {
    clickFX(btnReloadMap);
    wsSend({ t: "reload_map" });
  };

  btnResetPos.onclick = () => {
    clickFX(btnResetPos);
    wsSend({ t: "reset_positions" });
  };

  btnDash.onclick = () => {
    clickFX(btnDash);
    wsSend({ t: "dash" });
  };

  function clickFX(btn) {
    btn.style.transform = "scale(0.98)";
    setTimeout(() => btn.style.transform = "", 90);
  }

  function cleanName(s) {
    s = String(s || "").trim();
    if (!s) return "";
    s = s.replace(/[^\w\s\-]/g, "").trim();
    if (s.length > 14) s = s.slice(0, 14);
    return s;
  }

  function wsSend(obj) {
    if (!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify(obj));
  }

  // Character picker
  function buildCharUI() {
    charGrid.innerHTML = "";
    CHARACTERS.forEach(ch => {
      const div = document.createElement("div");
      div.className = "char" + (ch.id === selectedChar ? " selected" : "");
      div.onclick = () => {
        selectedChar = ch.id;
        // update selected styling
        [...charGrid.children].forEach(n => n.classList.remove("selected"));
        div.classList.add("selected");
        wsSend({ t: "pick", charId: selectedChar });
        // turning off ready on pick is handled server side, so mirror it
        isReady = false;
        btnReady.textContent = "Ready";
      };

      const icon = document.createElement("div");
      icon.className = "icon";
      icon.textContent = ch.key;

      const meta = document.createElement("div");
      meta.className = "meta";
      meta.innerHTML = `<div style="font-weight:800">${ch.label}</div><div class="small">${ch.trait}</div>`;

      div.appendChild(icon);
      div.appendChild(meta);
      charGrid.appendChild(div);
    });
  }

  function renderLobby() {
    if (!snapshot) return;

    lobbyList.innerHTML = "";
    const l = snapshot.lobby;

    lobbyModeText.textContent = `Mode: ${l.mode === "boss" ? "Boss Co-op" : "Obstacle Race"}`;

    if (snapshot.game) {
      lobbyMapText.textContent = `Map: ${snapshot.game.mapName || snapshot.game.mapId || "-"}`;
      hintEl.textContent = snapshot.game.hint || "";
      toastEl.textContent = snapshot.game.toast || "";
    } else {
      lobbyMapText.textContent = `Map: -`;
      hintEl.textContent = "";
      toastEl.textContent = "";
    }

    modeSelect.value = l.mode;

    (l.players || []).forEach(p => {
      const row = document.createElement("div");
      row.className = "playerRow";

      const left = document.createElement("div");
      left.className = "playerLeft";

      const dot = document.createElement("div");
      dot.className = "dot";
      dot.style.background = PALETTE[p.colorIndex % PALETTE.length];

      const who = document.createElement("div");
      who.innerHTML = `<div style="font-weight:800">${escapeHtml(p.name)} ${p.id === snapshot.room.hostId ? "<span class='tag'>HOST</span>" : ""}</div>
        <div class="small">${escapeHtml(labelForChar(p.charId))}</div>`;

      left.appendChild(dot);
      left.appendChild(who);

      const right = document.createElement("div");
      right.innerHTML = p.ready ? `<span class="tag">Ready</span>` : `<span class="tag" style="opacity:0.65">Not Ready</span>`;

      row.appendChild(left);
      row.appendChild(right);

      lobbyList.appendChild(row);
    });
  }

  function labelForChar(charId) {
    const c = CHARACTERS.find(x => x.id === charId);
    return c ? c.label : charId;
  }

  function escapeHtml(s) {
    s = String(s || "");
    return s.replace(/[&<>"']/g, (m) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[m]));
  }

  // Input and aiming
  function canAct() {
    if (!snapshot || !snapshot.game) return false;
    const g = snapshot.game;
    if (g.phase !== "play") return false;
    if (!myId) return false;
    if (g.turn.activeId !== myId) return false;
    if (g.turn.state !== "aim") return false;
    return true;
  }

  function worldToScreen(x, y) {
    return { x: x - cam.x, y: y - cam.y };
  }
  function screenToWorld(x, y) {
    return { x: x + cam.x, y: y + cam.y };
  }

  function pointerPos(ev) {
    const rect = c.getBoundingClientRect();
    const px = (ev.clientX - rect.left) * (c.width / rect.width);
    const py = (ev.clientY - rect.top) * (c.height / rect.height);
    return { x: px, y: py };
  }

  c.addEventListener("pointerdown", (ev) => {
    if (!canAct()) return;
    const p = snapshot.game.players[myId];
    if (!p) return;

    const sp = pointerPos(ev);
    const w = screenToWorld(sp.x, sp.y);

    // must click near your ball
    const d = Math.hypot(w.x - p.x, w.y - p.y);
    if (d > p.r + 18) return;

    dragging = true;
    dragStart = { x: p.x, y: p.y };
    dragNow = w;
    c.setPointerCapture(ev.pointerId);
  });

  c.addEventListener("pointermove", (ev) => {
    if (!dragging) return;
    const sp = pointerPos(ev);
    dragNow = screenToWorld(sp.x, sp.y);
  });

  c.addEventListener("pointerup", (ev) => {
    if (!dragging) return;
    dragging = false;

    if (!dragStart || !dragNow) return;

    const dx = dragStart.x - dragNow.x;
    const dy = dragStart.y - dragNow.y;

    // flick strength tuning
    const power = 6.2;
    const vx = clamp(dx * power, -2200, 2200);
    const vy = clamp(dy * power, -2200, 2200);

    wsSend({ t: "act", kind: "flick", vx, vy });

    dragStart = null;
    dragNow = null;
  });

  window.addEventListener("keydown", (ev) => {
    if (ev.code === "Space") {
      wsSend({ t: "dash" });
    }
  });

  // Rendering
  function updateCamera() {
    if (!snapshot || !snapshot.game || !myId) return;
    const g = snapshot.game;
    const me = g.players[myId];
    if (!me) return;

    // center on active player if it is your turn, else center on you
    const focusId = (g.turn.activeId && g.players[g.turn.activeId]) ? g.turn.activeId : myId;
    const f = g.players[focusId] || me;

    cam.w = c.width;
    cam.h = c.height;

    cam.x = f.x - cam.w * 0.5;
    cam.y = f.y - cam.h * 0.5;

    cam.x = clamp(cam.x, 0, Math.max(0, g.W - cam.w));
    cam.y = clamp(cam.y, 0, Math.max(0, g.H - cam.h));
  }

  function draw() {
    requestAnimationFrame(draw);

    ctx.clearRect(0, 0, c.width, c.height);

    if (!snapshot || !snapshot.game) {
      // idle background
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "rgba(255,255,255,0.06)";
      ctx.fillRect(30, 30, c.width - 60, c.height - 60);
      ctx.globalAlpha = 1;
      return;
    }

    const g = snapshot.game;
    updateCamera();

    // shake
    let sx = 0, sy = 0;
    if (g.shake && g.shake > 0) {
      sx = (Math.random() - 0.5) * g.shake;
      sy = (Math.random() - 0.5) * g.shake;
    }

    ctx.save();
    ctx.translate(sx, sy);

    // world bg
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = "rgba(0,0,0,0.2)";
    ctx.fillRect(0, 0, c.width, c.height);
    ctx.globalAlpha = 1;

    // draw walls
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    for (const w of g.walls) {
      const s = worldToScreen(w.x, w.y);
      ctx.fillRect(s.x, s.y, w.w, w.h);
    }

    // pads
    ctx.fillStyle = "rgba(120,160,255,0.28)";
    for (const p of g.pads) {
      const s = worldToScreen(p.x, p.y);
      ctx.fillRect(s.x, s.y, p.w, p.h);
    }

    // finish
    if (g.finish) {
      ctx.fillStyle = "rgba(80,255,160,0.22)";
      const s = worldToScreen(g.finish.x, g.finish.y);
      ctx.fillRect(s.x, s.y, g.finish.w, g.finish.h);
    }

    // traps
    ctx.fillStyle = "rgba(255,120,120,0.28)";
    for (const t of g.traps) {
      const s = worldToScreen(t.x, t.y);
      circle(s.x, s.y, t.r);
    }

    // hazards (boss)
    ctx.fillStyle = "rgba(255,160,80,0.28)";
    for (const hz of g.hazards || []) {
      const s = worldToScreen(hz.x, hz.y);
      circle(s.x, s.y, hz.r);
    }

    // coins
    ctx.fillStyle = "rgba(255,215,120,0.28)";
    for (const co of g.coins || []) {
      if (co.takenBy) continue;
      const s = worldToScreen(co.x, co.y);
      circle(s.x, s.y, co.r);
    }

    // items
    for (const it of g.items || []) {
      if (it.takenBy) continue;
      const s = worldToScreen(it.x, it.y);
      if (it.type === "dash") ctx.fillStyle = "rgba(120,180,255,0.30)";
      else if (it.type === "shield") ctx.fillStyle = "rgba(140,255,200,0.26)";
      else if (it.type === "magnet") ctx.fillStyle = "rgba(240,140,255,0.26)";
      else ctx.fillStyle = "rgba(255,255,255,0.18)";
      circle(s.x, s.y, it.r);
    }

    // boss
    if (g.boss) {
      const b = g.boss;
      const s = worldToScreen(b.x, b.y);

      // boss body
      ctx.fillStyle = "rgba(200,200,255,0.16)";
      circle(s.x, s.y, b.r);

      // weak spot arc indicator
      if (b.rules && b.rules.weakspot) {
        ctx.strokeStyle = "rgba(255,220,120,0.65)";
        ctx.lineWidth = 5;
        ctx.beginPath();
        const a0 = b.weakAngle - b.weakArc * 0.5;
        const a1 = b.weakAngle + b.weakArc * 0.5;
        ctx.arc(s.x, s.y, b.r + 10, a0, a1);
        ctx.stroke();
      }

      // parry ring
      if (b.ringActive) {
        const rs = worldToScreen(b.ringX, b.ringY);
        ctx.strokeStyle = "rgba(160,220,255,0.5)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(rs.x, rs.y, b.ringR, 0, Math.PI * 2);
        ctx.stroke();
      }

      // boss hp bar
      drawBar(18, 16, 280, 10, b.hp / Math.max(1, b.hpMax), "Boss HP");
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.font = "12px system-ui";
      ctx.fillText(`${b.name}`, 18, 48);
    }

    // players
    for (const pid in g.players) {
      const p = g.players[pid];
      const s = worldToScreen(p.x, p.y);

      const col = PALETTE[(p.colorIndex || 0) % PALETTE.length];

      // ball
      ctx.fillStyle = hexToRgba(col, 0.35);
      circle(s.x, s.y, p.r);

      // character style ring
      ctx.strokeStyle = hexToRgba(col, 0.85);
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(s.x, s.y, p.r + 2, 0, Math.PI * 2);
      ctx.stroke();

      // special: frog has double ring
      if (p.charId === "frog") {
        ctx.strokeStyle = "rgba(255,255,255,0.35)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(s.x, s.y, p.r - 6, 0, Math.PI * 2);
        ctx.stroke();
      }

      // shield indicator
      if (p.shield) {
        ctx.strokeStyle = "rgba(160,255,220,0.55)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(s.x, s.y, p.r + 8, 0, Math.PI * 2);
        ctx.stroke();
      }

      // name tag
      const nm = p.name || pid;
      drawNameTag(s.x, s.y - (p.r + 18), nm, pid === g.turn.activeId);

      // if boss mode: draw hp/lives small near player
      if (g.mode === "boss") {
        ctx.fillStyle = "rgba(255,255,255,0.85)";
        ctx.font = "11px system-ui";
        ctx.fillText(`HP ${p.hp}/${p.hpMax}  L ${p.lives}`, s.x - 28, s.y + (p.r + 18));
      }
    }

    // aim line
    if (dragging && dragStart && dragNow && canAct()) {
      const a = worldToScreen(dragStart.x, dragStart.y);
      const b = worldToScreen(dragNow.x, dragNow.y);
      ctx.strokeStyle = "rgba(255,255,255,0.45)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
    }

    // HUD text
    drawHudText(g);

    ctx.restore();
  }

  function drawHudText(g) {
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.font = "13px system-ui";

    const modeName = g.mode === "boss" ? "Boss Co-op" : "Obstacle Race";
    ctx.fillText(`Mode: ${modeName}`, 18, c.height - 56);
    ctx.fillText(`Round: ${g.round}`, 18, c.height - 36);

    const active = g.turn.activeId;
    const activeName = g.players[active]?.name || (active === "BOSS" ? "Boss" : active);
    ctx.fillText(`Turn: ${activeName} (${g.turn.state}, ${Math.ceil(g.turn.msLeft / 1000)}s)`, 18, c.height - 16);

    // dash button enable
    if (myId && g.players[myId]) {
      const me = g.players[myId];
      const canDash = (g.turn.activeId === myId && g.turn.state === "resolving" && (me.dashCharges || 0) > 0);
      btnDash.disabled = !canDash;
      btnDash.textContent = canDash ? `Dash (${me.dashCharges})` : `Dash`;
    }
  }

  function drawNameTag(x, y, text, highlight) {
    ctx.font = "12px system-ui";
    const pad = 6;
    const w = ctx.measureText(text).width + pad * 2;
    const h = 18;

    ctx.fillStyle = highlight ? "rgba(70,120,255,0.28)" : "rgba(0,0,0,0.35)";
    roundRect(x - w / 2, y - h / 2, w, h, 9);
    ctx.fill();

    ctx.strokeStyle = highlight ? "rgba(140,180,255,0.6)" : "rgba(255,255,255,0.14)";
    ctx.lineWidth = 1;
    roundRect(x - w / 2, y - h / 2, w, h, 9);
    ctx.stroke();

    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.fillText(text, x - w / 2 + pad, y + 4);
  }

  function drawBar(x, y, w, h, t, label) {
    t = clamp(t, 0, 1);
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fillRect(x, y, w, h);
    ctx.fillStyle = "rgba(120,180,255,0.35)";
    ctx.fillRect(x, y, w * t, h);

    ctx.fillStyle = "rgba(255,255,255,0.82)";
    ctx.font = "11px system-ui";
    ctx.fillText(label, x, y - 4);
  }

  function circle(x, y, r) {
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
  }

  function roundRect(x, y, w, h, r) {
    const rr = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  function hexToRgba(hex, a) {
    const h = hex.replace("#", "");
    const r = parseInt(h.slice(0,2), 16);
    const g = parseInt(h.slice(2,4), 16);
    const b = parseInt(h.slice(4,6), 16);
    return `rgba(${r},${g},${b},${a})`;
  }

  // Boot
  buildCharUI();
  connect();
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
